	public void MoveH(float moveH)
	{
		this.LiftSpeed.X = (double)Engine.DeltaTime != 0.0 ? moveH / Engine.DeltaTime : 0.0f;
		this.movementCounter.X += moveH;
		int move = (int)Math.Round((double)this.movementCounter.X);
		if (move == 0)
			return;
		this.movementCounter.X -= (float)move;
		this.MoveHExact(move);
	}

	public void MoveH(float moveH, float liftSpeedH)
	{
		this.LiftSpeed.X = liftSpeedH;
		this.movementCounter.X += moveH;
		int move = (int)Math.Round((double)this.movementCounter.X);
		if (move == 0)
			return;
		this.movementCounter.X -= (float)move;
		this.MoveHExact(move);
	}

	public void MoveV(float moveV)
	{
		this.LiftSpeed.Y = (double)Engine.DeltaTime != 0.0 ? moveV / Engine.DeltaTime : 0.0f;
		this.movementCounter.Y += moveV;
		int move = (int)Math.Round((double)this.movementCounter.Y);
		if (move == 0)
			return;
		this.movementCounter.Y -= (float)move;
		this.MoveVExact(move);
	}

	public void MoveV(float moveV, float liftSpeedV)
	{
		this.LiftSpeed.Y = liftSpeedV;
		this.movementCounter.Y += moveV;
		int move = (int)Math.Round((double)this.movementCounter.Y);
		if (move == 0)
			return;
		this.movementCounter.Y -= (float)move;
		this.MoveVExact(move);
	}

	public void MoveToX(float x) => this.MoveH(x - this.ExactPosition.X);

	public void MoveToX(float x, float liftSpeedX) => this.MoveH(x - this.ExactPosition.X, liftSpeedX);

	public void MoveToY(float y) => this.MoveV(y - this.ExactPosition.Y);

	public void MoveToY(float y, float liftSpeedY) => this.MoveV(y - this.ExactPosition.Y, liftSpeedY);

	public void MoveTo(Vector2 position)
	{
		this.MoveToX(position.X);
		this.MoveToY(position.Y);
	}

	public void MoveTo(Vector2 position, Vector2 liftSpeed)
	{
		this.MoveToX(position.X, liftSpeed.X);
		this.MoveToY(position.Y, liftSpeed.Y);
	}

	public void MoveTowardsX(float x, float amount) => this.MoveToX(Calc.Approach(this.ExactPosition.X, x, amount));

	public void MoveTowardsY(float y, float amount) => this.MoveToY(Calc.Approach(this.ExactPosition.Y, y, amount));

	public abstract void MoveHExact(int move);

	public abstract void MoveVExact(int move);

	public void MoveToNaive(Vector2 position)
	{
		this.MoveToXNaive(position.X);
		this.MoveToYNaive(position.Y);
	}

	public void MoveToXNaive(float x) => this.MoveHNaive(x - this.ExactPosition.X);

	public void MoveToYNaive(float y) => this.MoveVNaive(y - this.ExactPosition.Y);

	public void MoveHNaive(float moveH)
	{
		this.LiftSpeed.X = (double)Engine.DeltaTime != 0.0 ? moveH / Engine.DeltaTime : 0.0f;
		this.movementCounter.X += moveH;
		int num = (int)Math.Round((double)this.movementCounter.X);
		if (num == 0)
			return;
		this.movementCounter.X -= (float)num;
		globalPosition.x += (float)num;
		this.MoveStaticMovers(Vector2.right * (float)num);
	}

	public void MoveVNaive(float moveV)
	{
		this.LiftSpeed.Y = (double)Engine.DeltaTime != 0.0 ? moveV / Engine.DeltaTime : 0.0f;
		this.movementCounter.Y += moveV;
		int num = (int)Math.Round((double)this.movementCounter.Y);
		if (num == 0)
			return;
		this.movementCounter.Y -= (float)num;
		globalPosition.y += (float)num;
		this.MoveStaticMovers(Vector2.down * (float)num);
	}

	public bool MoveHCollideSolids(
		float moveH,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform> onCollide = null)
	{
		this.LiftSpeed.X = (double)Engine.DeltaTime != 0.0 ? moveH / Engine.DeltaTime : 0.0f;
		this.movementCounter.X += moveH;
		int moveH1 = (int)Math.Round((double)this.movementCounter.X);
		if (moveH1 == 0)
			return false;
		this.movementCounter.X -= (float)moveH1;
		return this.MoveHExactCollideSolids(moveH1, thruDashBlocks, onCollide);
	}

	public bool MoveVCollideSolids(
		float moveV,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform> onCollide = null)
	{
		this.LiftSpeed.Y = (double)Engine.DeltaTime != 0.0 ? moveV / Engine.DeltaTime : 0.0f;
		this.movementCounter.Y += moveV;
		int moveV1 = (int)Math.Round((double)this.movementCounter.Y);
		if (moveV1 == 0)
			return false;
		this.movementCounter.Y -= (float)moveV1;
		return this.MoveVExactCollideSolids(moveV1, thruDashBlocks, onCollide);
	}

	public bool MoveHCollideSolidsAndBounds(
		Level level,
		float moveH,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform> onCollide = null)
	{
		this.LiftSpeed.X = (double)Engine.DeltaTime != 0.0 ? moveH / Engine.DeltaTime : 0.0f;
		this.movementCounter.X += moveH;
		int moveH1 = (int)Math.Round((double)this.movementCounter.X);
		if (moveH1 == 0)
			return false;
		this.movementCounter.X -= (float)moveH1;
		double num1 = (double)this.Left + (double)moveH1;
		Rectangle bounds = level.Bounds;
		double left = (double)bounds.Left;
		bool flag;
		if (num1 < left)
		{
			flag = true;
			bounds = level.Bounds;
			moveH1 = bounds.Left - (int)this.Left;
		}
		else
		{
			double num2 = (double)this.Right + (double)moveH1;
			bounds = level.Bounds;
			double right = (double)bounds.Right;
			if (num2 > right)
			{
				flag = true;
				bounds = level.Bounds;
				moveH1 = bounds.Right - (int)this.Right;
			}
			else
				flag = false;
		}
		return this.MoveHExactCollideSolids(moveH1, thruDashBlocks, onCollide) | flag;
	}

	public bool MoveVCollideSolidsAndBounds(
		Level level,
		float moveV,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform> onCollide = null,
		bool checkBottom = true)
	{
		this.LiftSpeed.Y = (double)Engine.DeltaTime != 0.0 ? moveV / Engine.DeltaTime : 0.0f;
		this.movementCounter.Y += moveV;
		int moveV1 = (int)Math.Round((double)this.movementCounter.Y);
		if (moveV1 == 0)
			return false;
		this.movementCounter.Y -= (float)moveV1;
		int num = level.Bounds.Bottom + 32;
		bool flag;
		if ((double)this.Top + (double)moveV1 < (double)level.Bounds.Top)
		{
			flag = true;
			moveV1 = level.Bounds.Top - (int)this.Top;
		}
		else if (checkBottom && (double)this.Bottom + (double)moveV1 > (double)num)
		{
			flag = true;
			moveV1 = num - (int)this.Bottom;
		}
		else
			flag = false;
		return this.MoveVExactCollideSolids(moveV1, thruDashBlocks, onCollide) | flag;
	}

	public bool MoveHExactCollideSolids(
		int moveH,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform>? onCollide = null)
	{
		float x = globalPosition.x;
		int num = Math.Sign(moveH);
		int move = 0;
		Solid? solid = null;
		while (moveH != 0)
		{
			solid = CollideFirst<Solid>(globalPosition + Vector2.right * (float)num);
			if (solid == null)
			{
				move += num;
				moveH -= num;
				globalPosition = new(globalPosition.x + num, globalPosition.y);
			}
			else
				break;
		}
		globalPosition = new(x, globalPosition.y);
		MoveHExact(move);
		if (solid is not null && onCollide is not null)
			onCollide(Vector2.right * (float)num, Vector2.right * (float)move, (Platform)solid);
		return solid is not null;
	}

	public bool MoveVExactCollideSolids(
		int moveV,
		bool thruDashBlocks,
		Action<Vector2, Vector2, Platform>? onCollide = null)
	{
		float y = globalPosition.y;
		int num = Math.Sign(moveV);
		int move = 0;
		Platform? platform = null;
		while (moveV != 0)
		{
			platform = CollideFirst<Solid>(globalPosition + Vector2.down * (float)num);
			if (platform == null)
			{
				if (moveV > 0)
				{
					platform = this.CollideFirstOutside<JumpThru>(globalPosition + Vector2.down * (float)num);
					if (platform is not null)
						break;
				}
				move += num;
				moveV -= num;
				globalPosition = new(globalPosition.x, globalPosition.y + num);
			}
			else
				break;
		}
		globalPosition = new(globalPosition.x, y);
		this.MoveVExact(move);
		if (platform is not null && onCollide is not null)
			onCollide(Vector2.down * (float)num, Vector2.down * (float)move, platform);
		return platform is not null;
	}
